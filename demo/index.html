<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TTX-WASM: Font ‚áÑ XML Converter</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      .drop-zone.disabled {
        opacity: 0.3;
        cursor: not-allowed;
        pointer-events: none;
      }

      .drop-zone.disabled * {
        opacity: 0.4;
      }

      .drop-zone.disabled:hover,
      .drop-zone.disabled.dragover {
        border-color: #cbd5e0;
        background: white;
        transform: none;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Ubuntu', sans-serif;
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        color: #2d3748;
        line-height: 1.6;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .header {
        text-align: center;
        padding: 2rem 2rem;
        background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
        color: white;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      }

      .header h1 {
        font-size: 2.5rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .header p {
        font-size: 1.2rem;
        opacity: 0.95;
        font-weight: 300;
        max-width: 600px;
        margin: 0 auto;
      }

      .container {
        flex: 1;
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        width: 100%;
      }

      .status {
        text-align: center;
        padding: 1.5rem;
        margin-bottom: 2rem;
        border-radius: 12px;
        font-weight: 500;
        background: white;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        border: 1px solid #e2e8f0;
      }

      .status.loading {
        background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
        color: white;
        border: none;
      }

      .status.ready {
        background: linear-gradient(135deg, #a8edea 0%, #d6fee1 100%);
        color: #2d5a27;
        border: 1px solid #68d391;
      }

      .status.error {
        background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
        color: #742a2a;
        border: 1px solid #fc8181;
      }

      .drop-zone {
        border: 3px dashed #cbd5e0;
        border-radius: 16px;
        padding: 4rem 2rem;
        text-align: center;
        background: white;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-bottom: 2rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        position: relative;
        overflow: hidden;
      }

      .drop-zone::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          45deg,
          transparent 30%,
          rgba(102, 126, 234, 0.05) 50%,
          transparent 70%
        );
        transform: translateX(-100%);
        transition: transform 0.6s ease;
      }

      .drop-zone:hover::before {
        transform: translateX(100%);
      }

      .drop-zone:hover,
      .drop-zone.dragover {
        border-color: #3c9dbd;
        background: #f7fafc;
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);
      }

      .drop-zone-icon {
        font-size: 4rem;
        margin-bottom: 1rem;
        filter: grayscale(0.2);
      }

      .drop-zone h3 {
        font-size: 1.75rem;
        margin-bottom: 0.75rem;
        color: #2d3748;
        font-weight: 600;
      }

      .drop-zone p {
        color: #718096;
        font-size: 1.1rem;
        font-weight: 400;
      }

      .file-input {
        display: none;
      }

      .editor-container {
        display: none;
        flex-direction: column;
        height: 70vh;
        background: white;
        border-radius: 16px;
        overflow: hidden;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        border: 1px solid #e2e8f0;
      }

      .editor-container.visible {
        display: flex;
      }

      .editor-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1.5rem;
        background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 100%);
        color: white;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .editor-info {
        display: flex;
        gap: 1.5rem;
        align-items: center;
      }

      .file-name {
        font-weight: 600;
        font-size: 1.1rem;
        color: white;
      }

      .file-size {
        color: rgba(255, 255, 255, 0.8);
        font-size: 0.95rem;
        background: rgba(255, 255, 255, 0.1);
        padding: 0.25rem 0.75rem;
        border-radius: 20px;
      }

      .editor-actions {
        display: flex;
        gap: 1rem;
      }

      .btn {
        padding: 0.75rem 1.5rem;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.2s ease;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.95rem;
        position: relative;
        overflow: hidden;
        background: #f0fbff;
        color: #2d3748;
        border: 2px solid #e6f7ff;
      }

      .btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s ease;
      }

      .btn:hover::before {
        left: 100%;
      }

      .btn:hover {
        background: #e1f5fe;
        border-color: #b3e5fc;
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .editor {
        flex: 1;
        width: 100%;
        background: #fafafa;
        color: #2d3748;
        border: none;
        padding: 1.5rem;
        font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', Consolas, monospace;
        font-size: 14px;
        line-height: 1.6;
        resize: none;
        outline: none;
        transition: background-color 0.2s ease;
      }

      .editor:focus {
        background: white;
      }

      .spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-top: 3px solid white;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .hidden {
        display: none !important;
      }

      @media (max-width: 768px) {
        .header h1 {
          font-size: 2rem;
        }

        .header p {
          font-size: 1rem;
        }

        .container {
          padding: 1rem;
        }

        .drop-zone {
          padding: 3rem 1rem;
        }

        .editor-container {
          height: 60vh;
        }

        .editor-header {
          flex-direction: column;
          gap: 1rem;
          text-align: center;
        }

        .editor-actions {
          justify-content: center;
        }
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>TTX-WASM</h1>
      <p>Load a font, edit the XML, save the changes.</p>
    </div>

    <div class="container">
      <div id="status" class="status loading">
        <span class="spinner"></span>
        Loading TTX engine...
      </div>

      <div class="drop-zone" id="dropZone">
        <div class="drop-zone-icon">üìù</div>
        <h3>Drop your font file here</h3>
        <p>Supports TTF, OTF, WOFF, WOFF2, TTC, and TTX files ‚Ä¢ Click to browse</p>
        <input
          type="file"
          id="fileInput"
          class="file-input"
          accept=".ttf,.otf,.woff,.woff2,.ttc,.ttx"
        />
      </div>

      <div id="editorContainer" class="editor-container">
        <div class="editor-header">
          <div class="editor-info">
            <span id="fileName" class="file-name">font.ttx</span>
            <span id="fileSize" class="file-size">Loading...</span>
          </div>
          <div class="editor-actions">
            <button id="downloadTTX" class="btn">üíæ Download TTX</button>
            <button id="exportFont" class="btn">üöÄ Export Font</button>
            <button id="newFile" class="btn">üìÅ New File</button>
          </div>
        </div>
        <textarea
          id="xmlEditor"
          class="editor"
          placeholder="TTX XML content will appear here..."
        ></textarea>
      </div>
    </div>

    <script type="module">
      import { TTX } from './ttx-wasm.esm.js';

      class TTXDemo {
        constructor() {
          this.currentFile = null;
          this.currentFileName = '';
          this.isFont = false;

          this.initializeElements();
          this.setupEventListeners();
          this.initializeTTX();
        }

        initializeElements() {
          this.status = document.getElementById('status');
          this.dropZone = document.getElementById('dropZone');
          this.fileInput = document.getElementById('fileInput');
          this.editorContainer = document.getElementById('editorContainer');
          this.fileName = document.getElementById('fileName');
          this.fileSize = document.getElementById('fileSize');
          this.xmlEditor = document.getElementById('xmlEditor');
          this.downloadTTX = document.getElementById('downloadTTX');
          this.exportFont = document.getElementById('exportFont');
          this.newFile = document.getElementById('newFile');

          // Debug: Check for missing elements
          const elements = {
            status: this.status,
            dropZone: this.dropZone,
            fileInput: this.fileInput,
            editorContainer: this.editorContainer,
            fileName: this.fileName,
            fileSize: this.fileSize,
            xmlEditor: this.xmlEditor,
            downloadTTX: this.downloadTTX,
            exportFont: this.exportFont,
            newFile: this.newFile,
          };

          for (const [name, element] of Object.entries(elements)) {
            if (!element) {
              console.error(`Element not found: ${name}`);
            }
          }
        }

        setupEventListeners() {
          // Drop zone events
          if (this.dropZone) {
            this.dropZone.addEventListener('click', () => this.fileInput.click());
            this.dropZone.addEventListener('dragover', this.handleDragOver.bind(this));
            this.dropZone.addEventListener('dragleave', this.handleDragLeave.bind(this));
            this.dropZone.addEventListener('drop', this.handleDrop.bind(this));
          }

          // File input
          if (this.fileInput) {
            this.fileInput.addEventListener('change', this.handleFileSelect.bind(this));
          }

          // Buttons
          if (this.downloadTTX) {
            this.downloadTTX.addEventListener('click', this.downloadTTXFile.bind(this));
          }
          if (this.exportFont) {
            this.exportFont.addEventListener('click', this.exportFontFile.bind(this));
          }
          if (this.newFile) {
            this.newFile.addEventListener('click', this.resetInterface.bind(this));
          }
        }

        async initializeTTX() {
          try {
            this.updateStatus('loading', 'Initializing TTX engine...');
            this.dropZone.classList.add('disabled');
            await TTX.initialize();
            this.dropZone.classList.remove('disabled');
            this.updateStatus('ready', 'Ready! Drop a font file or TTX XML to get started.');
          } catch (error) {
            console.error('Failed to initialize TTX:', error);
            this.dropZone.classList.remove('disabled');
            this.updateStatus('error', 'Failed to initialize. Please refresh the page.');
          }
        }

        updateStatus(type, message) {
          this.status.className = `status ${type}`;
          this.status.innerHTML =
            type === 'loading' ? `<span class="spinner"></span> ${message}` : message;
        }

        handleDragOver(e) {
          e.preventDefault();
          this.dropZone.classList.add('dragover');
        }

        handleDragLeave(e) {
          e.preventDefault();
          this.dropZone.classList.remove('dragover');
        }

        handleDrop(e) {
          e.preventDefault();
          this.dropZone.classList.remove('dragover');

          const files = e.dataTransfer.files;
          if (files.length > 0) {
            this.processFile(files[0]);
          }
        }

        handleFileSelect(e) {
          const files = e.target.files;
          if (files.length > 0) {
            this.processFile(files[0]);
          }
        }

        async processFile(file) {
          this.currentFile = file;
          this.currentFileName = file.name;

          try {
            this.updateStatus('loading', `Processing ${file.name}...`);

            const fileExtension = file.name.toLowerCase().split('.').pop();
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);

            // Check file size (optional - warn about very large files)
            if (arrayBuffer.byteLength > 50 * 1024 * 1024) {
              // 50MB
              this.updateStatus(
                'error',
                'File is too large. Please select a file smaller than 50MB.'
              );
              return;
            }

            if (fileExtension === 'ttx' || fileExtension === 'xml') {
              // Handle TTX/XML file
              this.isFont = false;
              try {
                const xmlContent = new TextDecoder().decode(uint8Array);
                // Basic validation for TTX content
                if (!xmlContent.includes('<ttFont') && !xmlContent.includes('<?xml')) {
                  throw new Error('File does not appear to be a valid TTX or XML file');
                }
                this.showEditor(xmlContent, file.name, file.size);
                this.updateStatus('ready', `TTX file loaded. Edit and export as font.`);
              } catch (xmlError) {
                throw new Error(`Invalid TTX/XML file: ${xmlError.message}`);
              }
            } else {
              // Handle font file - validate extension first
              const supportedExtensions = ['ttf', 'otf', 'woff', 'woff2', 'ttc'];
              if (!supportedExtensions.includes(fileExtension)) {
                throw new Error(
                  `Unsupported file type: .${fileExtension}. Supported formats: TTF, OTF, WOFF, WOFF2, TTC, TTX`
                );
              }

              // Additional validation for font files
              if (arrayBuffer.byteLength < 100) {
                throw new Error('File is too small to be a valid font file');
              }

              this.isFont = true;
              try {
                const xmlContent = await TTX.dumpToTTX(uint8Array, {
                  tables: [], // Empty means all tables
                  disassembleInstructions: true,
                });
                this.showEditor(xmlContent, file.name.replace(/\.[^.]+$/, '.ttx'), null);
                this.updateStatus('ready', `Font converted to TTX. Edit and export.`);
              } catch (fontError) {
                // Parse specific error types for better user messages
                let errorMessage = fontError.message;

                if (errorMessage.includes('Not a TrueType or OpenType font')) {
                  errorMessage = `This file is not a valid font file. Please select a valid TTF, OTF, WOFF, WOFF2, or TTC file.`;
                } else if (errorMessage.includes('bad sfntVersion')) {
                  errorMessage = `Invalid font format detected. The file may be corrupted or not a standard font file.`;
                } else if (errorMessage.includes('checksum')) {
                  errorMessage = `Font file appears to be corrupted (checksum error). Please try a different file.`;
                } else if (errorMessage.includes('table')) {
                  errorMessage = `Font file has invalid or missing required tables. The file may be corrupted.`;
                } else {
                  errorMessage = `Unable to process font file: ${errorMessage}`;
                }

                throw new Error(errorMessage);
              }
            }
          } catch (error) {
            console.error('Error processing file:', error);
            this.updateStatus('error', error.message);
          }
        }

        showEditor(content, fileName, originalSize) {
          this.fileName.textContent = fileName;
          this.fileSize.textContent = originalSize
            ? this.formatFileSize(originalSize)
            : `${Math.round(content.length / 1024)} KB (XML)`;

          this.xmlEditor.value = content;
          this.editorContainer.classList.add('visible');
          this.dropZone.style.display = 'none';
        }

        async downloadTTXFile() {
          const content = this.xmlEditor.value;
          const blob = new Blob([content], { type: 'application/xml' });
          const url = URL.createObjectURL(blob);

          const a = document.createElement('a');
          a.href = url;
          a.download = this.fileName.textContent.endsWith('.ttx')
            ? this.fileName.textContent
            : `${this.fileName.textContent}.ttx`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }

        async exportFontFile() {
          try {
            this.updateStatus('loading', 'Converting TTX to font...');

            const xmlContent = this.xmlEditor.value;
            const fontData = await TTX.compileFromTTX(xmlContent);

            // Determine output filename and MIME type
            let outputName = this.currentFileName;
            let mimeType = 'font/ttf';

            if (this.isFont) {
              // Keep original extension if we started with a font
              outputName = this.currentFileName;
            } else {
              // Convert .ttx to .ttf if we started with TTX
              outputName = this.fileName.textContent.replace(/\.(ttx|xml)$/i, '.ttf');
            }

            // Detect font type from data for proper MIME type
            const header = new Uint8Array(fontData.slice(0, 4));
            const signature = Array.from(header)
              .map(b => String.fromCharCode(b))
              .join('');

            if (signature === 'OTTO') {
              mimeType = 'font/otf';
              if (outputName.endsWith('.ttf')) {
                outputName = outputName.replace('.ttf', '.otf');
              }
            }

            const blob = new Blob([fontData], { type: mimeType });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = outputName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            this.updateStatus('ready', `Font exported successfully as ${outputName}`);
          } catch (error) {
            console.error('Error exporting font:', error);
            this.updateStatus('error', `Export failed: ${error.message}`);
          }
        }

        resetInterface() {
          this.editorContainer.classList.remove('visible');
          this.dropZone.style.display = 'block';
          this.xmlEditor.value = '';
          this.currentFile = null;
          this.currentFileName = '';
          this.isFont = false;
          this.fileInput.value = '';
          this.updateStatus('ready', 'Ready! Drop a font file or TTX XML to get started.');
        }

        formatFileSize(bytes) {
          if (bytes === 0) return '0 Bytes';
          const k = 1024;
          const sizes = ['Bytes', 'KB', 'MB', 'GB'];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
      }

      // Initialize the demo when the page loads
      document.addEventListener('DOMContentLoaded', () => {
        new TTXDemo();
      });
    </script>
  </body>
</html>
